<!DOCTYPE html>

<html lang="en">

    <head>

        <title>three.js webgl - FBX loader with HDR Environment, Custom Material & Audio</title>

        <meta charset="utf-8">

        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <link type="text/css" rel="stylesheet" href="main.css">

    </head>



    <body>

        <div id="info">

            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - FBXLoader<br />

            Character and animation from <a href="https://www.mixamo.com/" target="_blank" rel="noopener">Mixamo</a>

            <p><strong>Nota: </strong>El audio se reproduce automaticamente en bucle.</p>

        </div>



        <script type="importmap">

            {

                "imports": {

                    "three": "../build/three.module.js",

                    "three/addons/": "./jsm/"

                }

            }

        </script>



        <script type="module">



            import * as THREE from 'three';



            import Stats from 'three/addons/libs/stats.module.js';



            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

            import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

           

            import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

            import { Audio, AudioListener, AudioLoader, TextureLoader } from 'three';



            const manager = new THREE.LoadingManager();



            let camera, scene, renderer, stats, object, loader, guiMorphsFolder;

            let mixer;



            const clock = new THREE.Clock();



            const params = {

                asset: 'Brooklyn Uprock'

            };



            const assets = [

                'Brooklyn Uprock',

                'morph_test',

                'monkey',

                'monkey_embedded_texture',

                'vCube',

            ];





            init();



            function init() {



                const container = document.createElement( 'div' );

                document.body.appendChild( container );



                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );

                camera.position.set( 100, 200, 300 );



                scene = new THREE.Scene();

               

                new RGBELoader( manager )

                    .setPath( './' )

                    .load( 'moon_lab_4k.hdr', function ( texture ) {



                        texture.mapping = THREE.EquirectangularReflectionMapping;



                        scene.background = texture;

                        scene.environment = texture;



                    } );

               

                // ðŸ’¡ AJUSTE DE ILUMINACIÃ“N: MÃ¡s intensidad y una luz auxiliar

                const shadowLight = new THREE.DirectionalLight( 0xffffff, 5 ); // Intensidad aumentada de 3 a 5

                shadowLight.position.set( 100, 300, 200 ); // PosiciÃ³n ajustada para iluminar mÃ¡s desde arriba/frente

                shadowLight.castShadow = true;

                shadowLight.shadow.camera.top = 180;

                shadowLight.shadow.camera.bottom = - 100;

                shadowLight.shadow.camera.left = - 120;

                shadowLight.shadow.camera.right = 120;

                shadowLight.shadow.mapSize.width = 1024;

                shadowLight.shadow.mapSize.height = 1024;

                scene.add( shadowLight );



                // ðŸ’¡ NUEVA LUZ: AÃ±adir una luz puntual o direccional adicional para rellenar

                const fillLight = new THREE.DirectionalLight(0xffffff, 2); // Luz de relleno con menor intensidad

                fillLight.position.set(-100, 200, -150); // Desde otro Ã¡ngulo para reducir sombras duras

                scene.add(fillLight);





                // ðŸ’¡ MODIFICACIÃ“N DEL PISO CON MÃS TEXTURAS (Diffuse y Normal Map)

                const textureLoader = new THREE.TextureLoader(manager);

               

                // Textura Diffuse (color) - Se carga la misma pero se "tiÃ±e" de blanco con el color del material

                const groundDiffuseTexture = textureLoader.load('models/textures/cobblestone/cobblestone_diffuse.jpg');

                groundDiffuseTexture.wrapS = THREE.RepeatWrapping;

                groundDiffuseTexture.wrapT = THREE.RepeatWrapping;

                groundDiffuseTexture.repeat.set(10, 10);

               

                // Textura Normal Map (para relieve)

                const groundNormalTexture = textureLoader.load('models/textures/cobblestone/cobblestone_normal.jpg');

                groundNormalTexture.wrapS = THREE.RepeatWrapping;

                groundNormalTexture.wrapT = THREE.RepeatWrapping;

                groundNormalTexture.repeat.set(10, 10);



                const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000 ), new THREE.MeshStandardMaterial( {

                    color: 0xffffff,               // ðŸ’¡ Color del suelo a blanco

                    map: groundDiffuseTexture,     // Textura de color

                    normalMap: groundNormalTexture, // Textura normal para el relieve

                    depthWrite: false,

                    metalness: 0.1,

                    roughness: 0.7

                } ) );

                mesh.rotation.x = - Math.PI / 2;

                mesh.receiveShadow = true;

                scene.add( mesh );



                const grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );

                grid.material.opacity = 0.2;

                grid.material.transparent = true;

                scene.add( grid );

           

                loader = new FBXLoader( manager );

                loadAsset( params.asset );



                const listener = new THREE.AudioListener();

                camera.add( listener );



                const sound = new THREE.Audio( listener );

                const audioLoader = new THREE.AudioLoader();

                audioLoader.load( 'models/rgbe/audio.mp3', function ( buffer ) {

                    console.log("Audio cargado exitosamente");

                    sound.setBuffer( buffer );

                    sound.setLoop( true );

                    sound.setVolume( 0.5 );

                    sound.play();

                } );



                renderer = new THREE.WebGLRenderer( { antialias: true } );

                renderer.setPixelRatio( window.devicePixelRatio );

                renderer.setSize( window.innerWidth, window.innerHeight );

                renderer.setAnimationLoop( animate );

                renderer.shadowMap.enabled = true;

               

                renderer.toneMapping = THREE.ACESFilmicToneMapping;

                renderer.toneMappingExposure = 1.5; // ðŸ’¡ ExposiciÃ³n aumentada de 1.2 a 1.5 para mÃ¡s brillo



                container.appendChild( renderer.domElement );



                const controls = new OrbitControls( camera, renderer.domElement );

                controls.target.set( 0, 100, 0 );

                controls.update();



                window.addEventListener( 'resize', onWindowResize );



                stats = new Stats();

                container.appendChild( stats.dom );



                const gui = new GUI();

                gui.add( params, 'asset', assets ).onChange( function ( value ) {



                    loadAsset( value );



                } );



                guiMorphsFolder = gui.addFolder( 'Morphs' ).hide();



            }



            function loadAsset( asset ) {



                loader.load( 'models/fbx/' + asset + '.fbx', function ( group ) {



                    if ( object ) {



                        object.traverse( function ( child ) {

                           

                            if ( child.isSkinnedMesh ) {

                                child.skeleton.dispose();

                            }

                            if ( child.material ) {

                                const materials = Array.isArray( child.material ) ? child.material : [ child.material ];

                                materials.forEach( material => {

                                    if ( material.map ) material.map.dispose();

                                    material.dispose();

                                } );

                            }

                            if ( child.geometry ) child.geometry.dispose();



                        } );



                        scene.remove( object );



                    }



                    //



                    object = group;



                    if ( object.animations && object.animations.length ) {



                        mixer = new THREE.AnimationMixer( object );



                        const action = mixer.clipAction( object.animations[ 0 ] );

                        action.play();



                    } else {



                        mixer = null;



                    }



                    guiMorphsFolder.children.forEach( ( child ) => child.destroy() );

                    guiMorphsFolder.hide();



                    object.traverse( function ( child ) {



                        if ( child.isMesh ) {

                           

                            child.castShadow = true;

                            child.receiveShadow = true;



                            if (child.material) {

                                const materials = Array.isArray(child.material) ? child.material : [child.material];

                                materials.forEach(material => {

                                    if (material.isMeshStandardMaterial) {

                                        material.envMapIntensity = 1.5; // ðŸ’¡ Aumenta la influencia del entorno HDR para el personaje

                                        material.needsUpdate = true;

                                    }

                                });

                            }





                            if ( child.morphTargetDictionary ) {



                                guiMorphsFolder.show();

                                const meshFolder = guiMorphsFolder.addFolder( child.name || child.uuid );

                                Object.keys( child.morphTargetDictionary ).forEach( ( key ) => {

           

                                    meshFolder.add( child.morphTargetInfluences, child.morphTargetDictionary[ key ], 0, 1, 0.01 );

           

                                } );

           

                            }



                        }



                    } );



                    scene.add( object );



                } );



            }



            function onWindowResize() {



                camera.aspect = window.innerWidth / window.innerHeight;

                camera.updateProjectionMatrix();



                renderer.setSize( window.innerWidth, window.innerHeight );



            }



            //



            function animate() {



                const delta = clock.getDelta();



                if ( mixer ) mixer.update( delta );



                renderer.render( scene, camera );



                stats.update();



            }



        </script>



    </body>

</html>
